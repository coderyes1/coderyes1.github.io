[{"content":"X86汇编 常见寄存器（64位） Ref: https://zhuanlan.zhihu.com/p/502718676\n通用寄存器(16个） rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8~r15\nrsi，rdi, rdx, rcx //用来参数传递（linux） rsp, rbp //指向栈顶与栈底 标志寄存器 rflags 标识指令执行的状态\n指令寄存器 rip 存放下一条指令的内存地址\n控制寄存器 控制CPU的工作状态，例如保护模式，分页等\n模型特定寄存器 这是一组寄存器，常常与一些新功能有关，例如VMX\n指令 push : esp-- + mov data *%esp 以下为对称设计 call ：push ip + jump enter : push ebp + mov %esp $ebp leave ：mov %ebp %esp + pop %ebp //与enter 搭配使用 ret ：pop ip + jump //与call搭配使用 lea 与 mov 区别\n1 2 3 4 5 6 mov %eax, %ebx # 把eax拷贝到ebx mov (%eax), %ebx # 把地址为eax的数据拷贝到ebx寄存器 mov 0x1(%eax), %ebx # 把地址为eax+1的数据拷贝到ebx寄存器 lea (%eax), %ebx # 把eax拷贝到ebx 与 mov %eax, %ebx 相同 lea 0x1(%eax), %ebx # 把eax+1拷贝到ebx(只是地址，不是数据) lea %eax, %ebx # 错误写法。 函数调用栈 C代码\n1 2 3 4 5 6 7 8 9 10 11 12 int fun(int a, int b) { int c=0; c = a + b; return c; } int main() { int a =1; int result = fun(a,2); return 0; } 反汇编代码(64位)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 00000000000005fa \u0026lt;_Z3funii\u0026gt;: 5fa: 55 push %rbp //压栈，用于后期还原，会修改esp 5fb: 48 89 e5 mov %rsp,%rbp //修改rbp, 两者指向同一个位置。 5fe: 89 7d ec mov %edi,-0x14(%rbp) //传入参数1，写到内存 601: 89 75 e8 mov %esi,-0x18(%rbp) //传入参数2，写到内存 604: c7 45 fc 00 00 00 00 movl $0x0,-0x4(%rbp) //内存上创建临时变量c 60b: 8b 55 ec mov -0x14(%rbp),%edx //从内存中读取参数1到寄存器 60e: 8b 45 e8 mov -0x18(%rbp),%eax //从内存中读取参数2到寄存器 611: 01 d0 add %edx,%eax //执行加法计算 613: 89 45 fc mov %eax,-0x4(%rbp) //结果从寄存器写入内存 616: 8b 45 fc mov -0x4(%rbp),%eax 619: 5d pop %rbp //将5fa中压入栈的地址还原 61a: c3 retq //pop ip,进而修改函数的执行顺序。 000000000000061b \u0026lt;main\u0026gt;: 61b: 55 push %rbp 61c: 48 89 e5 mov %rsp,%rbp 61f: 48 83 ec 10 sub $0x10,%rsp 623: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 62a: 8b 45 f8 mov -0x8(%rbp),%eax 62d: be 02 00 00 00 mov $0x2,%esi //待传参数放到寄存器1 632: 89 c7 mov %eax,%edi //待传参数放到寄存器2 634: e8 c1 ff ff ff callq 5fa \u0026lt;_Z3funii\u0026gt; //jump + push ip 639: 89 45 fc mov %eax,-0x4(%rbp) //将返回值从寄存器拷贝到内存 63c: b8 00 00 00 00 mov $0x0,%eax 641: c9 leaveq 642: c3 retq 643: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 64a: 00 00 00 64d: 0f 1f 00 nopl (%rax) 栈变化图解(右边表示指向此地址的寄存器)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #原始状态 data1 | esp data2 | ebp #after call old ip | esp data1 | data2 | ebp #at the begining of function, after push ebp, move esp ebp old ebp | esp\u0026amp;ebp old ip | data1 | data2 | #at the end of function, after mov rbp rsp , pop rbp old ip | esp data1 | data2 | ebp #after ret data1 | esp data2 | ebp 栈缩略图\n1 2 3 4 5 6 7 8 9 返回地址（old IP） ------前后栈分割线---------- old EBP（当前EBP寄存器指向此位置） 函数参数 局部变量 返回地址（old IP） ------前后栈分割线---------- old EBP（当前EBP寄存器指向此位置） ...... 函数的前后缀\n1 2 3 4 5 6 push %rbp # 把rbp指针压栈 mov %rsp,%rbp # 此时rbp，与rsp相同，都指向了一个 mov %rbp, %rsp pop %rbp ret # 就是pop %rip，还原到原来的位置。 Tips：\n有两套存储系统，分别是寄存器以及内存，其中cpu只能在寄存器上完成计算,内存的话分为代码区与数据区。ip寄存器与代码区打交道，ebp以及esp等与数据区打交道。 esp指向frame的最后一个数据，而非空数据。此值会随着push,pop修改，也可以手动改变。 mov 与movl，在这里一样，mov会被自动翻译成（movl） 汇编不能原操作地址与目的地址都是内存。 EBP就是暂存ESP的内容,EBP寄存器所指向地址内容为上一个EBP。可以通过加编译优化选项，将ebp优化掉。 32位参数传递与64位不同，32通过push到内存栈的方式，而64位通过寄存器的方式。 32位程序中__x86.get_pc_thunk.ax,是因为无法直接读取eip寄存器，会通过借助call，将eip寄存器内容push到内存中，然后mov 到ax，进而实现全局变量的访问。 程序在运行的时候，不断根据ip寄存器，取址执行，但是jmp,call,ret之类的指令会修改ip寄存器，改变程序执行的方向。 Ref: https://juejin.im/post/5d1d465051882579df4a4745\nInline assemble in C language 在C里面嵌入asm代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int src = 1; int dst; asm (\u0026#34;mov %1, %0\\n\\t\u0026#34; \u0026#34;add $1, %0\u0026#34; : \u0026#34;=r\u0026#34; (dst) : \u0026#34;r\u0026#34; (src)); printf(\u0026#34;%d\\n\u0026#34;, dst); return 0; } 格式一：\n1 2 3 4 5 asm asm-qualifiers ( AssemblerTemplate // %0,%1,%2分别代表了后面的第一个,第二个,第三个;AT\u0026amp;T格式默认从输入输出顺序为从左到右;常量需要加$符号 : OutputOperands // 输出必须要加+，r/m分别代表寄存器，也可同时指定，让编译器去决定。 : InputOperands // 输入不需要加= : Clobbers : GotoLabels) 格式二：就是不使用序号,使用符号,这里的d_c,e_c指定是c代码里的变量。\n1 2 3 asm(\u0026#34;mov %[e], %[d]\u0026#34; : [d] \u0026#34;=rm\u0026#34; (d_c) : [e] \u0026#34;rm\u0026#34; (*e_c)) 如果要对寄存器进行操作，需要加两个百分号， 例如：%%EAX\nclobber的作用如下：\n内联代码并非存粹的，不需要任何修改的汇编代码，gcc asm会进行相关的编译（载入c局部变量等），这时某些指令会修改额外的寄存器，或者汇编代码里面直接使用了某些寄存器，gcc并不知道，这里必须告诉gcc，我的asm代码中这个寄存器会被cloberring(修改)，你在转汇编代码的时候，不能使用这些寄存器。这里以clobber是否添加rax为例，对比了两个汇编的区别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int fun2() { int input =1; int output; asm(\u0026#34;mov $2, %[dst]\\n\\t\u0026#34; \u0026#34;add %[src], %[dst]\u0026#34; :[dst] \u0026#34;=rm\u0026#34; (output) :[src] \u0026#34;rm\u0026#34; (input) ); return 0; } int fun3() { int input =1; int output; asm(\u0026#34;mov $2, %[dst]\\n\\t\u0026#34; \u0026#34;add %[src], %[dst]\u0026#34; :[dst] \u0026#34;=rm\u0026#34; (output) :[src] \u0026#34;rm\u0026#34; (input) : \u0026#34;rax\u0026#34;); return 0; } 对应的汇编代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 0000000000001193 \u0026lt;fun2\u0026gt;: 1193: f3 0f 1e fa endbr64 1197: 55 push %rbp 1198: 48 89 e5 mov %rsp,%rbp 119b: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 11a2: b8 02 00 00 00 mov $0x2,%eax 11a7: 03 45 f8 add -0x8(%rbp),%eax 11aa: 89 45 fc mov %eax,-0x4(%rbp) 11ad: b8 00 00 00 00 mov $0x0,%eax 11b2: 5d pop %rbp 11b3: c3 retq 00000000000011b4 \u0026lt;fun3\u0026gt;: 11b4: f3 0f 1e fa endbr64 11b8: 55 push %rbp 11b9: 48 89 e5 mov %rsp,%rbp 11bc: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 11c3: ba 02 00 00 00 mov $0x2,%edx 11c8: 03 55 f8 add -0x8(%rbp),%edx 11cb: 89 55 fc mov %edx,-0x4(%rbp) 11ce: b8 00 00 00 00 mov $0x0,%eax 11d3: 5d pop %rbp 11d4: c3 retq 两个特别的参数：\ncc：修改了flag寄存器。 memory：告诉编译器，我的代码会对其他内存进行读写，这里加入一个barrier，让其他值flush到相关的寄存器。 PAUSE指令 spin-lock，如果一直在循环里，会让branch predictor 以为一直会执行循环的指令，但是如果某个时刻开始满足条件，就要flush整个pipeline，这会让锁的时间超过期望时间，加入PAUSE之后，会延缓内存的读取，这样整个pipeline不会填充满推测的指令了。\ntpause(timed pause)指令是对pause的优化，pause会消耗140个时钟周期，tpause会程序进入C0.1(弱睡眠)的状态，进而节省电量。 Ref: https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86 ","date":"2017-08-25T00:00:00Z","permalink":"https://www.coderyes.com/p/assemble/","title":"Assemble"},{"content":"虚函数 触发虚函数的三个条件：\n继承 声明虚函数 指针或者引用调用 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; class Base { public: virtual void fun() { std::cout \u0026lt;\u0026lt; \u0026#34;Base\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derive : public Base { //继承 public: virtual void fun() //声明虚函数 { std::cout \u0026lt;\u0026lt; \u0026#34;Derive\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Derive d; Base* p = \u0026amp;d; Base\u0026amp; r = d; p-\u0026gt;fun(); //指针或者引用调用成员函数 r.fun(); return 0; } 构造函数与析构函数 构造函数 析构函数 调用 创建对象时自动调用 析构对象时自动调用 作用 初始化成员 释放资源 重载 支持 不支持 构造函数的形式\n默认构造函数 拷贝构造函数 (用同类对象去初始化新对象) 转移构造函数（since C++11） 构造函数的调用时机\n函数参数值传递 (拷贝构造函数) 函数返回值传递 (拷贝构造函数) 对象构造对象 (拷贝构造函数) 临时对象构造对象 (转移构造函数) 普通变量构造对象 (默认构造函数) 条件变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;thread\u0026gt; // std::thread #include \u0026lt;mutex\u0026gt; // std::mutex, std::unique_lock #include \u0026lt;condition_variable\u0026gt; // std::condition_variable std::mutex mtx; std::condition_variable cv; bool ready = false; void print_id (int id) { std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mtx); while (!ready) cv.wait(lck); // ... std::cout \u0026lt;\u0026lt; \u0026#34;thread \u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } void go() { std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mtx); ready = true; cv.notify_all(); } int main () { std::thread threads[10]; // spawn 10 threads: for (int i=0; i\u0026lt;10; ++i) threads[i] = std::thread(print_id,i); std::cout \u0026lt;\u0026lt; \u0026#34;10 threads ready to race...\\n\u0026#34;; go(); // go! for (auto\u0026amp; th : threads) th.join(); return 0; } wait()函数执行流程\nunlock mutex wait 函数内部会unlock 以及lock\nblock current thread and wait for notify add this thread to waiting-list(or wait to be notified), once cv is notified, resume execution:\nunblock current thread. lock mutex here is important, because it will still wait mutex to unlock, ifnotify is under mutex\n注意虚假唤醒，需要通过外部变量进行 double check.\ncertain implementations may produce spurious wake-up calls without any of these functions being called Ref: http://www.cplusplus.com/reference/condition_variable/condition_variable/wait/\n不建议直接使用 wait,推荐使用 while wait 或者 带条件的 wait, 第一防止虚假唤醒，第二防止漏掉（如果notify的时候，线程不处于wait，就 wait 不到） notify最好不要在 mutex 里面，否则容易引发hurry up and wait的问题,示例代码如下。\nRef: https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; std::condition_variable cv; std::mutex cv_m; int i = 0; bool done = false; void waits() { std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting... \\n\u0026#34;; cv.wait(lk, []{return i == 1;}); std::cout \u0026lt;\u0026lt; \u0026#34;...finished waiting. i == 1\\n\u0026#34;; done = true; } void signals() { std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Notifying falsely...\\n\u0026#34;; cv.notify_one(); // waiting thread is notified with i == 0. // cv.wait wakes up, checks i, and goes back to waiting std::unique_lock\u0026lt;std::mutex\u0026gt; lk(cv_m); i = 1; while (!done) { std::cout \u0026lt;\u0026lt; \u0026#34;Notifying true change...\\n\u0026#34;; lk.unlock(); cv.notify_one(); // waiting thread is notified with i == 1, cv.wait returns std::this_thread::sleep_for(std::chrono::seconds(1)); lk.lock(); } } int main() { std::thread t1(waits), t2(signals); t1.join(); t2.join(); } join and detach join 阻塞当前线程，直到子线程结束运行 detach 分离线程，与当前线程没有关系 如果线程对象析构时未指定 detach 或者 join，将会导致程序crash.\nfuture async 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; bool is_prime(int x) { for (int i=0; i\u0026lt;x; i++) { if (x - i == 0) return false; } return true; } int main() { std::future\u0026lt;bool\u0026gt; fut = std::async(is_prime, 700020007); std::cout \u0026lt;\u0026lt; \u0026#34;please wait\u0026#34;; std::chrono::milliseconds span(100); while (fut.wait_for(span) != std::future_status::ready) std::cout \u0026lt;\u0026lt; \u0026#34;.\u0026#34;; std::cout \u0026lt;\u0026lt; std::endl; bool ret = fut.get(); std::cout \u0026lt;\u0026lt; \u0026#34;final result: \u0026#34; \u0026lt;\u0026lt; ret \u0026lt;\u0026lt; std::endl; return 0; } 首先创建线程执行 is_prime(700020007)，返回一个 std::future 对象。 主线程使用 std::future::wait_for 等待结果返回，wait_for 可设置最长等待时间。 任务完成，返回 std::future_status::ready 任务尚未完成，返回 std::future_status::timeout 主线程既可使用 std::future::get 获取结果，且主线程阻塞至任务完成。 promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;functional\u0026gt; // std::ref #include \u0026lt;thread\u0026gt; // std::thread #include \u0026lt;future\u0026gt; // std::promise, std::future void print_int(std::future\u0026lt;int\u0026gt;\u0026amp; fut) { std::cout \u0026lt;\u0026lt; \u0026#34;start wait\u0026#34;; int x = fut.get(); // 获取共享状态的值. std::cout \u0026lt;\u0026lt; \u0026#34;value: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 打印 value: 10. } int main() { std::promise\u0026lt;int\u0026gt; prom; // 生成一个 std::promise\u0026lt;int\u0026gt; 对象. std::future\u0026lt;int\u0026gt; fut = prom.get_future(); // 和 future 关联. std::thread t(print_int, std::ref(fut)); // 将 future 交给另外一个线程t. std::this_thread::sleep_for(std::chrono::seconds(5)); prom.set_value(10); // 设置共享状态的值, 此处和线程t保持同步. t.join(); return 0; } Promise 对象可保存 T 类型的值 get_future 来获取与 promise 对象关联的对象，调用该函数之后，两个对象共享相同的共享状态(shared state)。 Promise 对象某一时刻设置共享状态的值。 Future 对象可以返回共享状态的值（阻塞） packaged_task 相比与 async, 能够跟更加精细化控制线程的执行。\n三者对比 相同点： 获取异步线程中返回数据 不同点：\nasync 层次最高，你只需要给它提供一个函数，它就会返回一个 future 对象。接下来就只需等待结果了。 packaged_task 次之，你在创建了 packaged_task 后，还要创建一个 thread，并把 packaged_task 交给它执行。 promise 就最低，在创建了 thread 之后，你还要把对应的 promise 作为参数传入。这还没完，别忘了在函数中手动设置 promise 的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;chrono\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { std::packaged_task\u0026lt;int()\u0026gt; task([](){ std::chrono::milliseconds dura( 2000 ); std::this_thread::sleep_for( dura ); return 0; }); std::future\u0026lt;int\u0026gt; f1 = task.get_future(); std::thread(std::move(task)).detach(); std::future\u0026lt;int\u0026gt; f2 = std::async(std::launch::async, [](){ std::chrono::milliseconds dura( 2000 ); std::this_thread::sleep_for( dura ); return 0; }); std::promise\u0026lt;int\u0026gt; p; std::future\u0026lt;int\u0026gt; f3 = p.get_future(); std::thread([](std::promise\u0026lt;int\u0026gt; p){ std::chrono::milliseconds dura( 2000 ); std::this_thread::sleep_for( dura ); p.set_value(0); }, std::move(p)).detach(); std::cout \u0026lt;\u0026lt; \u0026#34;Waiting...\u0026#34; \u0026lt;\u0026lt; std::flush; f1.wait(); f2.wait(); f3.wait(); std::cout \u0026lt;\u0026lt; \u0026#34;Done!\\nResults are: \u0026#34; \u0026lt;\u0026lt; f1.get() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f2.get() \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; f3.get() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 线程池 C++ 线程池的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;functional\u0026gt; class ThreadPool { public: ThreadPool(size_t); //构造函数，size_t n 表示连接数 template\u0026lt;class F, class... Args\u0026gt; auto enqueue(F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args) //任务管道函数 -\u0026gt; std::future\u0026lt;typename std::result_of\u0026lt;F(Args...)\u0026gt;::type\u0026gt;; //利用尾置限定符 std future用来获取异步任务的结果 ~ThreadPool(); private: // need to keep track of threads so we can join them std::vector\u0026lt; std::thread \u0026gt; workers; //追踪线程 // the task queue std::queue\u0026lt; std::function\u0026lt;void()\u0026gt; \u0026gt; tasks; //任务队列，用于存放没有处理的任务。提供缓冲机制 std::mutex queue_mutex; //互斥锁 std::condition_variable condition; //条件变量？ bool stop; }; // the constructor just launches some amount of workers inline ThreadPool::ThreadPool(size_t threads) : stop(false) { for (size_t i = 0; i\u0026lt;threads; ++i) workers.emplace_back( //以下为构造一个任务，即构造一个线程 [this] { for (;;) { std::function\u0026lt;void()\u0026gt; task; //线程中的函数对象 {//大括号作用：临时变量的生存期，即控制lock的时间 std::unique_lock\u0026lt;std::mutex\u0026gt; lock(this-\u0026gt;queue_mutex); this-\u0026gt;condition.wait(lock, [this] { return this-\u0026gt;stop || !this-\u0026gt;tasks.empty(); }); //当stop==false\u0026amp;\u0026amp;tasks.empty(),该线程被阻塞 !this-\u0026gt;stop\u0026amp;\u0026amp;this-\u0026gt;tasks.empty() if (this-\u0026gt;stop \u0026amp;\u0026amp; this-\u0026gt;tasks.empty()) return; task = std::move(this-\u0026gt;tasks.front()); this-\u0026gt;tasks.pop(); } task(); //调用函数，运行函数 } } ); } // add new work item to the pool template\u0026lt;class F, class... Args\u0026gt; auto ThreadPool::enqueue(F\u0026amp;\u0026amp; f, Args\u0026amp;\u0026amp;... args) //\u0026amp;\u0026amp; 引用限定符，参数的右值引用， 此处表示参数传入一个函数 -\u0026gt; std::future\u0026lt;typename std::result_of\u0026lt;F(Args...)\u0026gt;::type\u0026gt; { using return_type = typename std::result_of\u0026lt;F(Args...)\u0026gt;::type; //packaged_task是对任务的一个抽象，我们可以给其传递一个函数来完成其构造。之后将任务投递给任何线程去完成，通过 //packaged_task.get_future()方法获取的future来获取任务完成后的产出值 auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;return_type()\u0026gt; \u0026gt;( //指向F函数的智能指针 std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...) //传递函数进行构造 ); //future为期望，get_future获取任务完成后的产出值 std::future\u0026lt;return_type\u0026gt; res = task-\u0026gt;get_future(); //获取future对象，如果task的状态不为ready，会阻塞当前调用者 { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(queue_mutex); //保持互斥性，避免多个线程同时运行一个任务 // don\u0026#39;t allow enqueueing after stopping the pool if (stop) throw std::runtime_error(\u0026#34;enqueue on stopped ThreadPool\u0026#34;); tasks.emplace([task]() { (*task)(); }); //将task投递给线程去完成，vector尾部压入 } condition.notify_one(); //选择一个wait状态的线程进行唤醒，并使他获得对象上的锁来完成任务(即其他线程无法访问对象) return res; }//notify_one不能保证获得锁的线程真正需要锁，并且因此可能产生死锁 // the destructor joins all threads inline ThreadPool::~ThreadPool() { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(queue_mutex); stop = true; } condition.notify_all(); //通知所有wait状态的线程竞争对象的控制权，唤醒所有线程执行 for (std::thread \u0026amp;worker : workers) worker.join(); //因为线程都开始竞争了，所以一定会执行完，join可等待线程执行完 } int main() { ThreadPool pool(4); std::vector\u0026lt; std::future\u0026lt;int\u0026gt; \u0026gt; results; for (int i = 0; i \u0026lt; 8; ++i) { results.emplace_back( pool.enqueue([i] { std::cout \u0026lt;\u0026lt; \u0026#34;hello \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;world \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; return i*i; }) ); } for (auto \u0026amp;\u0026amp; result : results) //通过future.get()获取返回值 std::cout \u0026lt;\u0026lt; result.get() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; std::endl; return 0; } Ref: https://github.com/progschj/ThreadPool/blob/master/ThreadPool.h\nstd::function 和 std::bind bind 函数主要用来当作一个函数适配器。\nauto f4 = std::bind(fun_1, n,placeholders::_1);\nf4：std::function fun1：函数名 n: 绑定的函数输入数值 place_holder: 使用时才输入值, 根据参数列表确定值传递还是引用传递 std 中使用 function 统一了\n普通函数 匿名函数(lambada) 含参函数(bind) 如果希望异步接受函数，可以通过 future 类(async,packaged_task,promise 来获取异步的结果)\n当调用 bind 函数时，值已经传入，或者认为形参已经生成，即使后期改变传入变量值，bind 函数只会按照传入时的值执行.\nRef: https://blog.csdn.net/liukang325/article/details/53668046\n四种类型转换 static_cast //静态转换，不会进行安全检查 dynamic_cast //动态转换，会执行安全检查 const_cast //将 const 转成非 const reinpreter_cast //强制成任意类型 Ref: http://www.cnblogs.com/welfare/articles/336091.html\n右值引用 可以给临时变量“续命” 1 2 int \u0026amp;\u0026amp;r1 = fun(); auto r2 = [] {return 5; }; 变量转移构造函数,避免深度拷贝 1 A(A\u0026amp;\u0026amp; a) {this.data=a.data} 完美转发 std::forward 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void processValue(int\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;lvalue\u0026#34; \u0026lt;\u0026lt; endl; } void processValue(int\u0026amp;\u0026amp; a) { cout \u0026lt;\u0026lt; \u0026#34;rvalue\u0026#34; \u0026lt;\u0026lt; endl; } template \u0026lt;typename T\u0026gt; void forwardValue(T\u0026amp;\u0026amp; val) { //这里切记，\u0026amp;\u0026amp;可以认为是一种接口约定，且仅限于模板中,如果是左值就翻译成（T\u0026amp; val）,如果是右值就翻译成(T\u0026amp;\u0026amp; val) //processValue(val); //无论左右值，都会按照左值进行转发 processValue(std::forward\u0026lt;T\u0026gt;(val)); //照参数本来的类型进行转发 } void Testdelcl() { int i = 0; forwardValue(i); //传入左值 forwardValue(0);//传入右值 } 输出： lvaue rvalue std::reference_wrapper 对应于C语言中的\u0026amp;,C++表达形式std::reference_wrapper\u0026lt;int\u0026gt; c = std::ref(a);\nrefernce_wrapper 相比于 T\u0026amp;的优点\n支持动态修改绑定对象 ref.get()返回的引用对象等同于 T\u0026amp; 通过 bind 机制在值传递函数中实现引用传递 变长参数函数 C语言中通过 va_list args 等去实现, 但C++中有三种选择，其中初始化列表是运行时，作为一个对象传入，其他都是编译期间自动推导的\ninitializer_list 通过大括号，生成一个 initializer_list 对象,将此作为一个大对象传入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //原始写法 std::vector\u0026lt;int\u0026gt; vec; vec.push_back(1); vec.push_back(3); vec.push_back(3); vec.push_back(2); //现代写法 std::vector\u0026lt;int\u0026gt; aa({1,2,3,4}); std::vector\u0026lt;int\u0026gt; aa={1,2,3,4}; //现代写法的其他场景 std::map\u0026lt;string, string\u0026gt; const nameToBirthday = { {\u0026#34;lisi\u0026#34;, \u0026#34;18841011\u0026#34;}, {\u0026#34;zhangsan\u0026#34;, \u0026#34;18850123\u0026#34;}, {\u0026#34;wangwu\u0026#34;, \u0026#34;18870908\u0026#34;}, {\u0026#34;zhaoliu\u0026#34;, \u0026#34;18810316\u0026#34;}, }; Ref: https://www.cnblogs.com/lysuns/p/4278589.html\n递归展开 需要有两个函数\n展开函数 终止函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; //递归终止函数 void print() { cout \u0026lt;\u0026lt; \u0026#34;empty\u0026#34; \u0026lt;\u0026lt; endl; } //展开函数 template \u0026lt;class T, class ...Args\u0026gt; void print(T head, Args... rest) { cout \u0026lt;\u0026lt; \u0026#34;parameter \u0026#34; \u0026lt;\u0026lt; head \u0026lt;\u0026lt; endl; print(rest...); } int main(void) { print(1,2,3,4); return 0; } 逗号表达式 编译期间{(printarg(args), 0)...}将会展开成((printarg(arg1),0), (printarg(arg2),0), (printarg(arg3),0), etc... )\n1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;class T\u0026gt; void printarg(T t) { cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; endl; } template \u0026lt;class ...Args\u0026gt; void expand(Args... args) { int arr[] = {(printarg(args), 0)...}; } expand(1,2,3,4); 模板元编程 将数值作为模板的参数，在编译期间就完成相关的计算, 例如求固定值的幂\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt;int NUM\u0026gt; class T { public: //enum { v = num * T\u0026lt;num - 1\u0026gt;::v }; also ok static const int value = NUM*T\u0026lt;NUM - 1\u0026gt;::value; }; template\u0026lt;\u0026gt; class T\u0026lt;1\u0026gt; { public: static const int value = 1; }; int main() { std::cout \u0026lt;\u0026lt; T\u0026lt;5\u0026gt;::value; return 0; } ## VS # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int fun_a() { return 0; } int fun_1() { return 5; } #define print1_1(x) {std::cout\u0026lt;\u0026lt;##x##;} #define print1_2(x) {std::cout\u0026lt;\u0026lt;x;} #define print2_1(x) {std::cout\u0026lt;\u0026lt;fun_##x##();} #define print2_2(x) {std::cout\u0026lt;\u0026lt;fun_x();} #define print3_1(x) {std::cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;#x;} int main(int i, char** args) { print1_1(1); print1_2(1); print2_1(a); //normal, expand to std::cout\u0026lt;\u0026lt;fun_a(); //print2_2(a); //error expand to std::cout\u0026lt;\u0026lt;fun_x(); int buffer_number = 5; print3_1(buffer_number); // normal, expand to std::cout\u0026lt;\u0026lt;buffer_number\u0026lt;\u0026lt;\u0026#34;buffer_number\u0026#34;; } ##var## 与 var 实际上一个东西，有点类似 cmake 中${var}，不过很多情况下可以省略##，因为没有歧异产生。如print1 的两个函数。但是在print2中就不能省，因为前后有其他有效字符（a-z,_,0-9）等，编译器会认为它们时一个整体，就不会替换，例如print2_2,这时候需要加##来进行强行替换，如print2_1。 #var 实际上时加了一个\u0026quot;\u0026quot;,能够打印出变量的内部名字。如print3_1 C与C++的可变参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; //base #define fun_1(str) {std::cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;std::endl;} //example of \u0026#34;#\u0026#34; #define fun_2(function) \\ { \\ if (!function)\\ {\\ std::cout \u0026lt;\u0026lt; \u0026#34;[Error] in\u0026#34; \u0026lt;\u0026lt; #function \u0026lt;\u0026lt; std::endl;\\ }\\ } //example of \u0026#34;##\u0026#34; #define fun_append(str1, str2, str3) \u0026#34;HASH:\u0026#34;##str1##str2##str3 //example of \u0026#34;VA_ARGS\u0026#34; #define LOG(...) fprintf(stdout, __VA_ARGS__) //mix example of virable agruments fuction and macro template\u0026lt;typename T\u0026gt; //must be ahead of template\u0026lt;typename T1, typename ...Rest\u0026gt; void print(T t) { std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T1, typename ...Rest\u0026gt; void print(T1 t1, Rest ...rest) { std::cout \u0026lt;\u0026lt; t1 \u0026lt;\u0026lt; std::endl; print(rest...); //rest... is a special virable,\u0026#34;rest\u0026#34; is nothing and cannot be used. } #define LOG2(...) print(__VA_ARGS__) int checkNegtive(int val) { return val \u0026lt; 0; } int main() { fun_1(\u0026#34;A\u0026#34;); fun_2(checkNegtive(10)); std::cout \u0026lt;\u0026lt; fun_append(\u0026#34;John\u0026#34;, \u0026#34;23\u0026#34;, \u0026#34;Male\u0026#34;) \u0026lt;\u0026lt; std::endl; LOG(\u0026#34;ww_%d\\n\u0026#34;, 39); LOG2(\u0026#34;love\u0026#34;, 4, \u0026#34;you\u0026#34;); return 0; } Ref: https://msdn.microsoft.com/zh-cn/library/dn439779.aspx?f=255\u0026MSPPError=-2147217396\n少用#define 类型安全，无需括号\nconst 取代 define 变量 inline 取代 define 函数 构造函数执行顺序 基类构造函数 成员构造函数 自身构造函数 当没有指定构造函数时，隐式的构造函数如下所示：D():Base(),Member(){};当需要指定初始值时，就需要显示调用构造函数了。 推荐使用初始化表，避免某些编辑器二次赋值 执行顺序与初始化表无关，与定义顺序有关 对象的两个指针 this指针: 调用成员函数时，由编辑器传入。（成员函数也是一种普通函数） 虚表指针: 同一类型的对象各自拥有一个指针，指向同一个表 new 与 delete流程 new\n申请空间 指针转换 构造函数 delete\n析构函数 释放空间 overwrite 与 overload overwrite 只适用于虚函数 //这里的 write 指的是重写虚函数表 overload 适用于函数重载 modern C++ 两大关键改进 变参模板 std::move 操作 pragma once 这只能防止在一个 cpp 文件中重复包含一个.h 文件，而不是所有的 cpp 只包含一次，因为每个 cpp 都是独立编译的。因此，不要在头文件中定义变量。\nvolatile 背景：编译器优化过程中，会检查变量是否修改过，如果没有修改，可能直接从 cpu 缓存等缓存中读取，而不是内存。\n方法：通过设置 volatile，避免编译器的优化，强制从内存中获取变量，而不是 CPU 的缓存。 遇到以下两种应用场景：\n当汇编与 c 代码混合编程时，编译器无法知道汇编代码中是否修改过变量，可能直接从 cpu 缓存中读取，导致错误。 断点调试并且通过外部命令行进行变量设置，如果不设置成 volatile，就可能导致变量外部设置失败。 enum class 推荐使用enum class 代替enum ，否则以下操作就会通过编译，进而带来安全隐患。\n1 2 3 4 5 6 enum Color { black, white, red }; enum Size {big, small }; Color cl=Color::black; Size sz=Size::big; if (sz == cl) //bad code if (1==sz) //bad code RTTI 机制 运行时类型检查\ntypeid 函数： 如果有虚函数，执行动态检查，否则执行静态检查。 dynamic_cast： 一般用于向下的类型转换，运行时会动态检查以及调整。 //占用运行时间，且有其他隐患 Ref: https://www.jianshu.com/p/3b4a80adffa7\n虚继承 为了解决菱形继承中数据双份的问题，比如\n1 2 3 4 5 6 7 8 9 10 11 class Animal { int weight=0; } class CrawlAnimal : public Animal { } class MammalAnimal : public Animal { } //horse 既是爬行动物又是哺乳动物，所以可能会继承这两个类。但是weight就会有两份 虚继承相比于普通的继承，子类会多出一个指针，这个指针(virtual base table pointer)指向一个表，这个表记录了父类成员的偏移值。当这中类再次被继承的时候（这里指的普通继承），会重写 virtual base table 的值以及合并虚基类对象，并且保留只有一个对象。\nRef: https://blog.csdn.net/xiejingfa/article/details/48028491\n实验代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct A { int data_a; virtual void print() { std::cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; std::endl; } }; struct B : public virtual A { virtual void Bprint() { std::cout \u0026lt;\u0026lt; \u0026#34;B_only\u0026#34; \u0026lt;\u0026lt; std::endl; } }; struct C : public virtual A { virtual void print() { std::cout \u0026lt;\u0026lt; \u0026#34;C\u0026#34;\u0026lt;\u0026lt;std::endl; } }; struct D : public B, public C { //virtual void print() { std::cout \u0026lt;\u0026lt; \u0026#34;B_only\u0026#34; \u0026lt;\u0026lt; std::endl; } //virtual void print() { std::cout \u0026lt;\u0026lt; \u0026#34;D\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { std::cout \u0026lt;\u0026lt; sizeof(A); std::cout \u0026lt;\u0026lt; sizeof(B); std::cout \u0026lt;\u0026lt; sizeof(C); std::cout \u0026lt;\u0026lt; sizeof(D); D d; d.print(); d.A::print(); } /*vs 输出结果 8 16 12 20 C A */ 1 2 3 4 5 内存分布 A: VPTR_a | data_a B: VBPTR_a | VPTR_b | VPTR_a | data_a C: VBPTR_a | VPTR_a | data_a //因为 C 中没有新加虚函数，所以不需要第二个虚表指针。 D: VBPTR_a | VPTR_b| VBPTR_a | VPTR_a | data_a //两个 VBPTR 分别继承自 B C 两个对象 继承中的内存分布 简单继承\n1 2 Base data Added data 虚函数\n1 2 3 VPTR //创建一个新表并覆盖重写，VPTR 指向新表 Base data Added data 虚继承\n1 2 3 VBPTR //VBPTR 指向表，此表记录了 BaseData 的偏移值 Added data Base data 1. 头部新增 base class table pointer 2. 旧数据移至最后 虚函数+虚继承\n1 2 3 4 5 VPTR_new // 新虚函数表指针（指向了新增的虚函数） VBPTR //VBPTR 指向表，此表记录了 BaseData 的偏移值 Added data VPTR_old // 旧虚函数表指针 Base data 多重继承过程中，虚继承的部分执行合并操作。 继承过程中，无论是虚表指针，还是虚类表指针都需要重写，所指向内容也需要新建。 thread_local 每次线程拥有一个独立的 static 对象。而不是全局的 static 对象。\n反射机制 java 可以在运行时动态获取对象的方法以及变量。\n注意,指向派生类对象的基类指针只能调用基类中声明过的方法以及成员,不可以运行时增加，所以 c++没有反射机制。Ref: https://www.zhihu.com/question/24304289/answer/150310001\nmutable 一般用于设置此变量可修改，即使在 const 函数中。\n还有一个应用就是 lambda 表达式中，修改值捕获的量，但是这不多见。\n模板 template 模板实例化的过程（由模板变成普通函数或者类）\n自动推导参数/指定参数 只有函数模板支持自动推导，而且未必能成功（C++17支持类模板自动推导） 参数可以是类型参数，也可以是非类型参数\n替换参数，将具体参数替换不同的模板，每个模板生成一个的函数接口 这里仅仅是函数接口推导，不编译 之所以有多个模板，因为函数的重载，类模板不存在此情况，只会有一个模板 特例化模板与通用模板属于同一个模板\n接口推导，丢弃推导失败的与保留推导成功的接口。 SFINAE,”从一组重载函数中删除模板实例化无效的函数”。 至少要有一个候选项，否则就失败。\n编译函数，选择最优的接口编译。 如果最优接口中存在特化，直接编译特化。 有可能出现 ambiguity\n模板偏特化 Demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 template\u0026lt;class T1, class T2, int I\u0026gt; class A {}; // primary template template\u0026lt;class T, int I\u0026gt; class A\u0026lt;T, T*, I\u0026gt; {}; // #1: partial specialization where T2 is a pointer to T1 template\u0026lt;class T, class T2, int I\u0026gt; class A\u0026lt;T*, T2, I\u0026gt; {}; // #2: partial specialization where T1 is a pointer template\u0026lt;class T\u0026gt; class A\u0026lt;int, T*, 5\u0026gt; {}; // #3: partial specialization where T1 is int, I is 5, template\u0026lt;\u0026gt; class A\u0026lt;int, int, 5\u0026gt; {}; // #4: fully specialization 注意事项：\n特例化用在模板之后 类后面写全部参数 template 后面声明未特例化的参数(包括类型参数与非类型参数)。 SFINAE SFINAE 的的全称是 Substitution Failure Is Not An Error。In the process of template argument deduction, a C++ compiler attempts to instantiate signatures of a number of candidate overloaded functions to make sure that exactly one overloaded function is available as a perfect match for a given function call. https://www.jianshu.com/p/45a2410d4085\n大白话，就是针对多个模板同时推倒，不需要每个模板都正确，有失败的无所谓，只要有一个活着就可以。应用最为广泛的场景是 C++中的std::enable_if\n首先利用特例化模板，生成一个有效或者无效的类型，并将此类型传递至下一次推导 利用SFINAE，选出了支持的函数。 enable_if 内部实现原理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template\u0026lt;bool x, typename T1=void\u0026gt; class MyEnable { public: MyEnable() { std::cout \u0026lt;\u0026lt; \u0026#34;default\u0026#34;; } }; //specialization template template\u0026lt;typename T\u0026gt; class MyEnable\u0026lt;true,T\u0026gt; { public: typedef T type; MyEnable() { std::cout \u0026lt;\u0026lt; \u0026#34;second\u0026#34;; } }; enable_if 的使用 demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //自己实现的常用的example,设置print2仅支持两种类型vector\u0026lt;int\u0026gt;,vector\u0026lt;string\u0026gt;。 template \u0026lt;class T\u0026gt; typename std::enable_if\u0026lt;std::is_same\u0026lt;T, std::vector\u0026lt;int\u0026gt;::value\u0026gt;::value, void\u0026gt;::type print2(T\u0026amp; i) { for (const auto\u0026amp; p: i) std::cout \u0026lt;\u0026lt; p; } template \u0026lt;class T\u0026gt; typename std::enable_if\u0026lt;std::is_same\u0026lt;T, std::vector\u0026lt;std::string\u0026gt;::value\u0026gt;, void\u0026gt;::type print2(T\u0026amp; i) { for (const auto\u0026amp; p: i) std::cout \u0026lt;\u0026lt; p; } //case 1: T = int 两者都推导失败，编译错误 //case 2: T = vector\u0026lt;int\u0026gt; 前者成功，后者失败 //case 3：T = vector\u0026lt;string\u0026gt; 前者失败，后者成功 type traits is_same 判断两个类型是否相等。 1 2 3 4 5 6 7 //常规用法 bool isInt = std::is_same\u0026lt;int, int\u0026gt;::value; //为true //但其检查很严格，如下 std::cout \u0026lt;\u0026lt; \u0026#34;int, const int: \u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;int, const int\u0026gt;::value \u0026lt;\u0026lt; std::endl;//false std::cout \u0026lt;\u0026lt; \u0026#34;int, int\u0026amp;: \u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;int, int\u0026amp;\u0026gt;::value \u0026lt;\u0026lt; std::endl;//false std::cout \u0026lt;\u0026lt; \u0026#34;int, const int\u0026amp;: \u0026#34; \u0026lt;\u0026lt; std::is_same\u0026lt;int, const int\u0026amp;\u0026gt;::value \u0026lt;\u0026lt; std::endl;//false decay 1 2 3 4 5 6 7 //能够进行类型退化，再进行类型检查 typedef std::decay\u0026lt;int\u0026gt;::type A; // int typedef std::decay\u0026lt;int\u0026amp;\u0026gt;::type B; // int typedef std::decay\u0026lt;int\u0026amp;\u0026amp;\u0026gt;::type C; // int typedef std::decay\u0026lt;const int\u0026amp;\u0026gt;::type D; // int typedef std::decay\u0026lt;int[2]\u0026gt;::type E; // int* typedef std::decay\u0026lt;int(int)\u0026gt;::type F; // int(*)(int) Ref: https://blog.csdn.net/czyt1988/article/details/52812797\nremove_cv remove either const and/or volatile,其中 decay 中包括了这个操作。\n1 2 3 4 typedef const volatile char cvchar; std::remove_cv\u0026lt;cvchar\u0026gt;::type a; // char a std::remove_cv\u0026lt;char* const\u0026gt;::type b; // char* b std::remove_cv\u0026lt;const char*\u0026gt;::type c; // const char* c (no changes) 类似的操作还有\n1 2 remove_pointer remove_const tuple 1 2 3 4 5 6 7 8 9 10 11 int main() { auto t = std::make_tuple(1, \u0026#34;Foo\u0026#34;, 3.14); // 基于下标的访问 std::cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;0\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;1\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;2\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; // 基于类型的访问 std::cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;int\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;const char*\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; std::get\u0026lt;double\u0026gt;(t) \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; // 注意： std::tie 和结构化绑定亦可用于分解 tuple } enable_if 主要作用就是当某个 condition 成立时，enable_if 可以提供某种类型, 具体见上面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; #define Print(trait) std::cout\u0026lt;\u0026lt;#trait\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;std::##trait\u0026lt;T\u0026gt;::value\u0026lt;\u0026lt;std::endl template \u0026lt;typename T\u0026gt; struct Show { Show() { Print(is_void); Print(is_null_pointer); Print(is_integral); Print(is_floating_point); Print(is_array); Print(is_enum); Print(is_union); Print(is_class); Print(is_function); Print(is_pointer); Print(is_lvalue_reference); Print(is_rvalue_reference); Print(is_member_object_pointer); Print(is_member_function_pointer); Print(is_fundamental); Print(is_arithmetic); Print(is_scalar); Print(is_object); Print(is_compound); Print(is_reference); Print(is_member_pointer); Print(is_const); Print(is_volatile); Print(is_trivial); Print(is_trivially_copyable); Print(is_standard_layout); } }; int main() { Show\u0026lt;int\u0026gt;(); return 0; } 字符集 ASCII 编码 计算机设计之初\nANSI 编码（本地化）\n2 个字节来表示 1 个字符。比如：汉字 ‘中’ 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。\nUNICODE（国际化） 国际组织制定了 UNICODE 字符集，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨语言、跨平台进行文本转换、处理的要求。\n区分字符集与编码(utf-8,16,32)，字符集建立数字与字符之间的映射关系，编码为了省内存 visual studio 中Multi-Byte Character Set(ANSI)与Unicode Character Set，前者每个字符占字节数不固定，后者每个字符占有两个字节，当设置 unicode 时，内部定义 unicode 宏，对于_T(\u0026ldquo;xxx\u0026rdquo;),内部会在字符串前面加 L\u0026quot;..\u0026quot;，但是前者就不会进行任何操作。std::string 默认前者，std::wstring 使用后者。 Ref: https://blog.csdn.net/luoweifu/article/details/49382969\nBase64 编码 目的: 是把二进制码转成可打印的 str，便于在网络(http 请求，邮件等)上传输。 原理：每 64bit 转成对应的一个符号。\nRef: https://www.ruanyifeng.com/blog/2008/06/base64.html\n左右值 简单来说，常规自定义变量为左值，右边值就是没有名字的临时值。c++类可以根据对象的左右值属性调用不同的函数，如下所示。 https://stackoverflow.com/a/28066865/10108544\n\u0026amp;符号在 c++的多种含义 用在变量声明处，申明引用 加载变量前面，取地址 表达式之间，按位与 用在函数参数列表中，引用传递 T\u0026amp;\u0026amp; 左值引用可以绑定任何值，但是右值引用只能绑定右值。 \u0026amp;\u0026amp; 与右值引用并不是完全划等号。 universal reference(\u0026amp;\u0026amp;) 两个条件：T\u0026amp;\u0026amp;以及 deduced type T(且不能加任何修饰)) auto\u0026amp;\u0026amp; 也是一个 URef URef handle everything.然后根据实际情况变成 LRef 或者 RRef。 not all T\u0026amp;\u0026amp; in template are URefs;\n1 2 3 4 5 6 7 8 9 template\u0026lt;class T\u0026gt; class vector { public: void push_back(const T\u0026amp; x); //LRef void push_back(T\u0026amp;\u0026amp; x); //RRef, 因为这里的T不是自动推导，而是外部指定而来的。 template\u0026lt;class... Args\u0026gt; void emplace_back(Args\u0026amp;\u0026amp;... args); // URef } 右值引用后，参数仍然为左值\n1 2 3 4 5 void doWork(Widget\u0026amp;\u0026amp; param) { //param 的类型是一个右值引用，但是他是一个左值，因为可以取名字。 //通常这种结构，需要std::move(param). } T\u0026amp;\u0026amp; 前面加了任何东西，都不是 URef，而是 RRef\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); //URef template\u0026lt;typename T\u0026gt; void f(const T\u0026amp;\u0026amp; param); //RRef template\u0026lt;typename T\u0026gt; void f(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; param); //RRef 推导冲突合并\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); Widget w; f(w); //推导出 T is Widget\u0026amp; //函数的接口变为 void f\u0026lt;Widget\u0026amp;\u0026gt;(Widget\u0026amp; \u0026amp;\u0026amp; param); //合并后的接口为 void f\u0026lt;Widget\u0026amp;\u0026gt;(Widget\u0026amp; param); f(std::move(w)); //推导出 T is Widget //函数的接口变为 void f\u0026lt;Widget\u0026gt;(Widget\u0026amp;\u0026amp;) //以下是引用合并规则 T\u0026amp; \u0026amp; = T\u0026amp; T\u0026amp;\u0026amp; \u0026amp; = T\u0026amp; T\u0026amp; \u0026amp;\u0026amp; = T\u0026amp; T\u0026amp;\u0026amp; \u0026amp;\u0026amp; = T\u0026amp;\u0026amp; Ref: https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11\nremove_cv 的用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; int main() { typedef std::remove_cv\u0026lt;const int\u0026gt;::type type1; typedef std::remove_cv\u0026lt;volatile int\u0026gt;::type type2; typedef std::remove_cv\u0026lt;const volatile int\u0026gt;::type type3; typedef std::remove_cv\u0026lt;const volatile int*\u0026gt;::type type4; typedef std::remove_cv\u0026lt;int * const volatile\u0026gt;::type type5; std::cout \u0026lt;\u0026lt; \u0026#34;test1 \u0026#34; \u0026lt;\u0026lt; (std::is_same\u0026lt;int, type1\u0026gt;::value ? \u0026#34;passed\u0026#34; : \u0026#34;failed\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;test2 \u0026#34; \u0026lt;\u0026lt; (std::is_same\u0026lt;int, type2\u0026gt;::value ? \u0026#34;passed\u0026#34; : \u0026#34;failed\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;test3 \u0026#34; \u0026lt;\u0026lt; (std::is_same\u0026lt;int, type3\u0026gt;::value ? \u0026#34;passed\u0026#34; : \u0026#34;failed\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;test4 \u0026#34; \u0026lt;\u0026lt; (std::is_same\u0026lt;const volatile int*, type4\u0026gt;::value ? \u0026#34;passed\u0026#34; : \u0026#34;failed\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;test5 \u0026#34; \u0026lt;\u0026lt; (std::is_same\u0026lt;int*, type5\u0026gt;::value ? \u0026#34;passed\u0026#34; : \u0026#34;failed\u0026#34;) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 注意 type4 与 type5 的区别，const volatile int* 这些修饰符并不是修饰的指针本身，而是指针所指的对象，所以 type4 并没有变化，而 type5 修饰的是指针本生，所以变成了int*.\n可变参数模板 解释：针对输入参数不确定的情况下，可以考虑使用可变参数模板 原理：其内部会根据函数模板递归推导出很多函数。 用法：掌握好三个名字\ntypename... Args is called a template parameter pack Args... args is called a function parameter pack args... 参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename T\u0026gt; decltype(auto) fun(T t) { return t; } template\u0026lt;typename T,typename ...Args\u0026gt; decltype(auto) fun(T t,Args... args) { return t+fun(args...); } int main() { std::cout\u0026lt;\u0026lt;fun(10, 20, 30); return 0; } 函数参数第一个都需要普通的参数传递，这样在迭代的过程中，随着深度的增加，参数越来越少。 c++17 中可以使用迭代(fold expression)代替递归。 析构函数 调用子类的析构函数，会自动调用父类的析构函数 为什么需要将父类的析构函数声明为虚函数？ 因为 new 的是子类对象，调用的是子类的构造函数，但是 delete 却是基类的指针，调用的是基类的析构函数，不会执行子类的析构函数。 所以将父类析构函数声明为虚函数，这样会进行虚函数查表自动调用到子类的析构函数，同时子类析构会自动调用父类析构，父类的析构函数也会执行。 引用 常见于两种情况：\nBase\u0026amp; a= Derive();实现多态 引用传递与引用返回来避免拷贝，以及直接修改值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //原理上就是指针 void fun(A\u0026amp; a) { a.data = 3; } A a fun(a); //等价版本 void p_fun(A* p_a) { p_a-\u0026gt;data = 3; } A a; p_fun(\u0026amp;a); ///////////////////////////////////////////////// A\u0026amp; get() { A temp; return temp; } A a; a = get(); //等价版本 A* get() { A temp; return \u0026amp;temp; } A a; a = *(get()); //可以看出如果不用引用去接受返回值，一样要进行拷贝，并没有达到目的。 lambda 表达式 lambda 表达式本质上是函数，不过这个函数没有名字（匿名函数）。他的参数传递有两个阶段，第一是捕获，第二是常规传递。常规传递可忽略。这里着重说明一下捕获操作。 捕获分为值捕获以及引用捕获。\n[=]捕获操作里面会执行拷贝，捕获的时候，会缓存这个变量 [\u0026amp;]没有拷贝。 [this] 就在成员函数里面，捕获 this 指针，就可以访问所有的成员变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //test code class A { public: int data; A(int d) { data = d; } A(const A\u0026amp; a) { data = a.data; std::cout \u0026lt;\u0026lt;data\u0026lt;\u0026lt; \u0026#34;copy....\\n\u0026#34;\u0026lt;\u0026lt;std::endl; } }; int main() { A aa{ 123 }; std::cout \u0026lt;\u0026lt; \u0026#34;original data = \u0026#34; \u0026lt;\u0026lt; aa.data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; auto lambuda1 = [=]() {std::cout \u0026lt;\u0026lt; \u0026#34;lambuda1 data = \u0026#34; \u0026lt;\u0026lt; aa.data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; auto lambuda2 = [\u0026amp;]() {std::cout \u0026lt;\u0026lt; \u0026#34;lambuda2data = \u0026#34; \u0026lt;\u0026lt; aa.data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; }; aa.data = 100; std::cout \u0026lt;\u0026lt; \u0026#34;changed data = \u0026#34; \u0026lt;\u0026lt; aa.data \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; lambuda1(); lambuda2(); return 0; } 循环引用 使用类的前向声明，可以解决循环引用的问题。\nreturn 返回 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Test { public: int data{0}; Test() = default; Test(const Test\u0026amp; t) :data(t.data) { std::cout \u0026lt;\u0026lt; \u0026#34;copy constructor\u0026#34;\u0026lt;\u0026lt;std::endl; } void operator=(const Test\u0026amp; t) { data = t.data; std::cout \u0026lt;\u0026lt; \u0026#34;assign constructor\u0026#34; \u0026lt;\u0026lt; std::endl; } Test\u0026amp; getDataByReference() { return *this; } Test getDataByValue() { return *this; } }; int main() { Test t; std::cout \u0026lt;\u0026lt; \u0026#34;------------test1-----------------\\n\u0026#34;; Test t1_1 = t.getDataByReference(); //with copy (copy constructor) Test t1_2; t1_2 = t.getDataByReference(); //with copy (assign constructor) Test\u0026amp; t1_3 = t.getDataByReference(); //without copy t.getDataByReference(); //without copy too. //test 2 std::cout \u0026lt;\u0026lt; \u0026#34;------------test2-----------------\\n\u0026#34;; Test t2_1 = t.getDataByValue(); //with copy (copy constructor) Test t2_2; t2_2 = t.getDataByValue(); //with copy twice(copy constructor, then assign constructor) Test\u0026amp; t2_3 = t.getDataByValue(); //with copy (copy constructor) t.getDataByValue(); //with copy (copy constructor) Test\u0026amp;\u0026amp; t2_4 = t.getDataByValue(); //with copy (copy constructor) return 0; } 返回类型为引用\n接收类型与返回类型同时为引用时，才是真正的引用（不会发生拷贝）。t1_2 直接将返回值当左值使用也行。t1_3 返回类型为值\n都会发生至少一次的内存拷贝。 t2_3, t2_4 只有一次，第二次是引用，引用了临时创建的变量（右值）。 t2_1 只有一次，因为编译器的优化，如果没有优化就是两次相同的拷贝构造函数，现在就变成了直接拷贝到新建的对象了，不需要再有临时对象去中转了。 t2_2 发生两次 copy，首先生成了一个临时变量，然后在由这个临时变量去调用赋值函数。这里的两次 copy 是无法优化的。因为是两个不同的函数，return 返回调用拷贝构造，赋值调用=重载函数。 智能指针的简单实现 两个指针指着两个堆对象（data 与 counter） 析构函数，只有计数为 0 的时候，才执行 delete 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Data { public: int m_data{ 10 }; ~Data() { std::cout \u0026lt;\u0026lt; \u0026#34;Deconstruct.\\n\u0026#34;; } }; template \u0026lt;class DataType\u0026gt; class SharePointer { size_t* m_counter = nullptr; DataType* m_data = nullptr; public: SharePointer(DataType* data) { m_counter = new size_t(); *m_counter = 1; m_data = data; } SharePointer(const SharePointer\u0026amp; p) { m_counter = p.m_counter; m_data = p.m_data; (*m_counter)++; } ~SharePointer() { (*m_counter) -= 1; if (*m_counter == 0) { delete m_data; delete m_counter; } } }; int main() { SharePointer\u0026lt;Data\u0026gt; p1(new Data()); SharePointer\u0026lt;Data\u0026gt; p2 = p1; SharePointer\u0026lt;Data\u0026gt; p3 = p2; } 交叉引用本质的原因，智能指针析构时，引用计数不为 0，不能 delete 对象。\n工程项目小技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;assert.h\u0026gt; #include \u0026lt;limits\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; //the following 3 ways to exit program during the differnt step. //1. exit compiling via MACRO when some env are not correct. #if !defined(WIN32) #error \u0026#34;it only supported in windows OS\u0026#34;. #endif //2. exit compiling during template deducing when some var are not correct. template\u0026lt;typename T, int size\u0026gt; struct A { A() { static_assert(std::is_arithmetic\u0026lt;T\u0026gt;::value, \u0026#34;only supports arithmetic types\u0026#34;); static_assert(!(size \u0026gt; 300), \u0026#34;size is too large\u0026#34;); static_assert(!(sizeof(T) \u0026gt;4), \u0026#34;type is too large\u0026#34;); } }; void static_asserdemo() { A\u0026lt;int, 10\u0026gt; a; //A\u0026lt;int, 1000\u0026gt; b; //A\u0026lt;void*, 10\u0026gt; c; } //3. exit program during running if some var is empty. //it only works for Debug, because there are \u0026#34;#define NDEBUG\u0026#34; in other modes. void* checkPointer() { std::cout \u0026lt;\u0026lt; \u0026#34;run\u0026#34;\u0026lt;\u0026lt;__func__\u0026lt;\u0026lt;std::endl; return nullptr; } void assertdemo(const char* path = nullptr) { assert(checkPointer()); //this function won\u0026#39;t run in other modes except debug. } int main() { return 0; } 统一初始化 C++ 11 之后，引入{}来统一初始化.\n避免歧义 1 2 3 4 Widget w1(10); // 调用Widget的带参构造函数 Widget w2(); //声明函数 Widget w2{}; // 无歧义 Widget w2; // 无歧义 类内成员的默认初始值 1 2 3 4 5 6 7 class Widget { ... private: int x{ 0 }; // x的默认初始值为0 int y = 0; // 同上 int z( 0 ); // 报错 } std::initializer_list 在构造函数中，只要形参不带有 std::initializer_list，圆括号和大括号行为一致. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Widget { public: Widget(int i, bool b); Widget(int i, double d); ... }; Widget w1(10, true); // 调用第一个构造函数 Widget w2{10, true}; // 调用第一个构造函数 Widget w3(10, 5.0); // 调用第二个构造函数 Widget w4{10, 5.0}; // 调用第二个构造函数 但是如果有（不能当成普通的容器处理）,就会强制使用 std::initializer_list(即使参数正常匹配)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Widget { public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list\u0026lt;long double\u0026gt; il); ... }; Widget w1(10, true); // 使用圆括号，调用第一个构造函数 Widget w2{10, true}; // 使用大括号，强制调用第三个构造函数，10和true被转换为long double Widget w3(10, 5.0); // 使用圆括号，调用第二个构造函数 Widget w4{10, 5.0}; // 使用大括号，强制调用第三个构造函数，10和5.0被转换为long double 但是有个特殊情况,即使用了{},也会调用非 std::initializer_list 的函数。\n1 2 3 4 5 6 7 8 9 10 class Widget { public: Widget(); Widget(std::initializer_list\u0026lt;int\u0026gt; il); ... }; Widget w1; // 调用默认构造函数 Widget w2{}; // 调用默认构造函数 Widget w4({}); // 用了一个空的list来调用带std::initializer_list构造函数 Ref: https://zhuanlan.zhihu.com/p/268894227\n哈希函数 C++标准库中提供了基本的哈希函数，能够将 key 转成 hash_code(int)，这里 key 的类型包括常见的 int,float,void,string 等等。但是如果是自定义的类，就需要自己去些哈希函数，转成一个 int。这里的 hash_code 只是一个值，并非地址索引。一般来说，key 不会相同，hash_code 可以相同（冲突），但这回导致索引时间增长。\n分配器 可以重写 allocate 与 deallocate 方法来自定义分配细节，来控制实际分配的内存。 不可以改变容器的扩充策略（尽管有些时候也是过度请求）。 比如，分配不同 device 的内存（非 cpu memory），只能自定义分配器。 比如，当 vector 的 size 是 4,且 capacity 也是 4,这时候继续 push,那 vector 可能要求分配 8,而这时候我们可以多分配些，避免多次申请。 比如，当 list 不断与释放内存的时候，后台可以做成一个内存池。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; class mmap_allocator : public std::allocator\u0026lt;T\u0026gt; { public: typedef size_t size_type; typedef T* pointer; typedef const T* const_pointer; template\u0026lt;typename _Tp1\u0026gt; struct rebind { typedef mmap_allocator\u0026lt;_Tp1\u0026gt; other; }; pointer allocate(size_type n, const void* hint = 0) { fprintf(stderr, \u0026#34;Alloc %d bytes.\\n\u0026#34;, n * sizeof(T)); return std::allocator\u0026lt;T\u0026gt;::allocate(n); } void deallocate(pointer p, size_type n) { fprintf(stderr, \u0026#34;Dealloc %d bytes (%p).\\n\u0026#34;, n * sizeof(T), p); return std::allocator\u0026lt;T\u0026gt;::deallocate(p, n); } mmap_allocator() throw() : std::allocator\u0026lt;T\u0026gt;() { fprintf(stderr, \u0026#34;Hello allocator!\\n\u0026#34;); } mmap_allocator(const mmap_allocator\u0026amp; a) throw() : std::allocator\u0026lt;T\u0026gt;(a) { } template \u0026lt;class U\u0026gt; mmap_allocator(const mmap_allocator\u0026lt;U\u0026gt;\u0026amp; a) throw() : std::allocator\u0026lt;T\u0026gt;(a) { } ~mmap_allocator() throw() { } }; int main() { std::vector\u0026lt;int, mmap_allocator\u0026lt;int\u0026gt;\u0026gt; aa; } fold expression（折叠表达式） 可以使用这个替换模板的循环递归。\n只支持一个运算符的不断递归 没有递归调用，只是括号内的迭代展开，最终形成一个很长的括号内容。 左右不同顺序，导致括号顺序不同。 ...代表折叠内容，args代表已展开内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template\u0026lt;typename ...Args\u0026gt; int sum1(Args\u0026amp;\u0026amp;... args) { return (args + ...); } template\u0026lt;typename ...Args\u0026gt; int sum2(Args\u0026amp;\u0026amp;... args) { return (... + args); } template\u0026lt;typename ...Args\u0026gt; void print(Args\u0026amp;\u0026amp;... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt;args); } int main() { sum1(1, 2, 3); //(1+(2+3)) sum2(1, 2, 3); //((1+2)+3) print(1, 2, \u0026#34;str\u0026#34;); //(((std::cout\u0026lt;\u0026lt;1)\u0026lt;\u0026lt;2)\u0026lt;\u0026lt;\u0026#34;str\u0026#34;) } 类型推导 T 可能被推导为T\u0026amp;\u0026amp; T\u0026amp;/T* T\nRef: https://www.bilibili.com/video/BV1H7411n7FJ?p=9\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void f(T\u0026amp; param); int x = 22; const int cx = x; const int\u0026amp; rx = x; f(x); //T=int, param type = int\u0026amp; f(cx); //T=const int, param type = const int\u0026amp; f(rx); //T=const int, param type = const int\u0026amp; 1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void f(const T\u0026amp; param); int x = 22; const int cx = x; const int\u0026amp; rx = x; f(x); //T=int, param type = int\u0026amp; f(cx); //T=int, param type = const int\u0026amp; f(rx); //T=int, param type = const int\u0026amp; 1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void f(T* param); int x = 22; const int* pcx = \u0026amp;x; f(\u0026amp;x); //T=int, param type = int* f(pcx); //T=const int, param type = const int* 1 2 3 4 5 6 7 8 9 int x = 22; const int cx = x; const int\u0026amp; rx = x; auto\u0026amp; v1 =x; //auto=int, param type= int\u0026amp; auto\u0026amp; v2 = cx; //auto=const int, param type=const int\u0026amp; auto\u0026amp; v3 = rx; //auto=const int, param type=const int\u0026amp; const auto\u0026amp; v4 = x; //auto=int, param type= const int\u0026amp; const auto\u0026amp; v5 = cx; //auto=int, param type= const int\u0026amp; const auto\u0026amp; v6 = rx; //auto=int, param type= const int\u0026amp; 1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename T\u0026gt; void f(T\u0026amp;\u0026amp; param); f(expr); int x = 22; const int cx = x; const int \u0026amp;rx = x; f(x); //T=int\u0026amp;, param type = int \u0026amp; f(cx); //T=const int\u0026amp;, param type =const int \u0026amp; f(rx); //T=const int\u0026amp;, param type =const int \u0026amp; f(22); //T=int, param type = int \u0026amp;\u0026amp; 1 2 3 4 5 6 7 8 9 10 11 template\u0026lt;typename T\u0026gt; void f(T param); f(expr); int x = 22; const int cx = x; const int \u0026amp;rx = x; f(x); //T=int, param type = int f(cx); //T=const int, param type =const int f(rx); //T=const int, param type =const int 1 2 3 4 5 6 7 8 9 10 int x = 22; const int cx = x; const int \u0026amp;rx = x; auto v1 =x; //auto=int ,param type = int auto v2 =cx; //auto=int ,param type = int auto v3 =rx; //auto=int ,param type = int auto v4 =rx; //auto=int, param type = int auto \u0026amp; v5 = rx; //param type = const int\u0026amp; auto\u0026amp;\u0026amp; v6 = rx; //param type = const int\u0026amp; auto 在推导的时候，忽略 refence 以及 const. expr's reference/const qualifiers always dropped in deducing T auto 不会推导出引用，引用需要用户手动加上去。 自定义对象支持auto遍历 结构体需要支持 begin 以及 end 函数。\n1 2 3 4 5 6 7 8 9 10 struct cstring { const char* ptr = 0; const char* begin() const { return ptr?ptr:\u0026#34;\u0026#34;; }// return empty string if we are null null_sentinal_t end() const { return {}; } }; cstring str{\u0026#34;abc\u0026#34;}; for (char c : str) { std::cout \u0026lt;\u0026lt; c; } Ref: https://stackoverflow.com/questions/8164567/how-to-make-my-custom-type-to-work-with-range-based-for-loops\ngcc in windows MinGW is the gcc compiler in windows. Cygwin provide the emulation layer of Uninx api in Windows. MSYS2 is a fork version of Cygwin, there are a little difference. https://www.msys2.org/wiki/How-does-MSYS2-differ-from-Cygwin/ https://www.reddit.com/r/cpp_questions/comments/39p86k/q_can_some_one_explain_the_difference_between/ ","date":"2017-08-25T00:00:00Z","permalink":"https://www.coderyes.com/p/c-/","title":"C++"},{"content":" high-performance static-linked built-in goroutine Reference: https://www.w3schools.com/go/index.php\nrun go run .\\hello.go build binary go build .\\helloworld.go .\\helloworld.go ending style ending a line (hitting the Enter key) a semicolon \u0026ldquo;;\u0026rdquo; variable definition two way to define a var\n1 2 3 4 5 6 7 8 9 10 11 package main import (\u0026#34;fmt\u0026#34;) func main() { var student1 string = \u0026#34;John\u0026#34; //type is string var student2 = \u0026#34;Jane\u0026#34; //type is inferred x := 2 //type is inferred fmt.Println(student1) fmt.Println(student2) fmt.Println(x) } print Go has three functions to output text:\n1 2 3 Print() // very basic Println() // add whitespace and white space Printf() // just like printf in c++ println is built-in function and will be removed eventually. fmt.println is standard library.\nbasic numeric int Depends on platform: 32 bits in 32 bit systems and 64 bit in 64 bit systems\narray fixed length\n1 2 var array_name = [length]datatype{values} // here length is defined var array_name = [...]datatype{values} // here length is inferred slice dynamic length\n1 slice_name := []datatype{values} map To declare a structure in Go, use the type and struct keywords:\n1 2 3 4 5 6 type struct_name struct { member1 datatype; member2 datatype; member3 datatype; ... } argument pass basic: pass by value(numeric, string\u0026hellip;) complex: pass by pointer(map, slice, channel) there in no reference pass(literally) but pointer pass in Go lang channel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) } By default, send and receive will block, without locks or cv make vs new new return T*, which is a pointer make return T, which is only used for (slice, channel and map) 1 2 3 4 5 6 7 new(int) new(Point) \u0026amp;Point{} \u0026amp;Point{2, 3} // Combines allocation and initialization var m map[string]int; m = make(map[string]int); import package the exported function must start with uppercase package is same to directory in some degree, the files in a folder should be in the same package import \u0026quot;folder_path\u0026quot; is not a package but a folder name, but in most cases we make them identical. import str \u0026quot;strings\u0026quot; can give a alias name ","date":"2017-08-25T00:00:00Z","permalink":"https://www.coderyes.com/p/go/","title":"Go"},{"content":"basic concept python 中一切皆为对象，即使类本身也是一种对象(类对象/Class Objects)，所以避免使用其他语言中的instance,而是instance object,class object,method object. 使用attribute(属性)来表达成员的含义，有数据属性以及方法属性,一个object=数据属性+方法属性 function与method有区别，前者一般指普通函数，后者一般指的是bounding method(instance object 的方法属性） 我的形象理解，python的世界中，有三种层级的对象，分别负责创建下一级别的对象，由上到下是type关系，不是继承关系 第一阶级：metaclass/type object。 第二阶级：class object。 第三阶级：instance object. 常说的UML图中，描述的是同一阶级内部之间的继承关系（主要第二层），与不同阶级无关。python可以用issubclass() 检查。 type()可以查看其上一层级的object，或者说这个对象是由哪个类对象创造的 metaclass比较神奇，因为其type为自身。其父类也是自身。 object类对象，跨越一二层，是他们公共的父类。 第一阶层，实际编程很少需要考虑。 python中所有的方法都是虚方法 与C不同，在函数内部默认不使用全部变量，除非使用global指定，且if,for,while,try之类的关键字不会产生作用域。 python3 中的round()函数并不是四舍五入的，应该是 四舍，六入，五选偶，这样做是保证总误差不会被累积。 lambda函数的写法 lambda x: x+1 map() 在python中一个函数，而非Dict(),注意与C++区别，他会给每个元素执行一遍函数，并且返回一个可以迭代的map对象。也可以通过list()等方法，转成list对象。 sort方法会inplace修改对象，sorted不会。 string 1 2 3 4 5 6 7 8 9 a = \u0026#34;123\u0026#34; b = a a = \u0026#34;456\u0026#34; # 字符串之间的拷贝都是深拷贝 print (b) path_t =r\u0026#34;D:\\worksapce_python\\20160426_cp\\training\u0026#34; # 禁止使用转义字符 a = 123 b = 456 c1 = f\u0026#34;a={a}, b={b}\u0026#34; # 两种初始化方法 1 c2 = \u0026#34;a={}, b={}\u0026#34;.format(a,b) # 两种初始化方法 2 container 1 2 3 4 5 6 7 8 9 10 #list, 顺序容器，支持随机访问，类似c++中的std::vector. data = list() data = [] #两种初始化方法 #set/dict, 无序哈希表，不是RB tree，但在python3中遍历顺序与插入顺序相同。 data = {} #{}默认带key,即dict data = dict() data = set() #tuple, 不可改变的list data = () data = tuple() class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MyBaseClass: # 类命名一般使用驼峰 def __init__(self): # 初始化函数，self是约定俗成的，不是强制的 self.name = \u0026#34;name\u0026#34; # 在这里增加数据属性，也可以在外部添加 self._counter = 0 # 私有变量一般使用_开头，外部也可以强制访问 def print_name(self): # 方法属性命名一般使用下划线开头 print(self.name, \u0026#34;this is the \u0026#34;, self._counter, \u0026#34;time\u0026#34;) self._counter += 1 class MyDerivedClass(MyBaseClass): pass if __name__ == \u0026#34;__main__\u0026#34;: base = MyBaseClass() base2 = base derived = MyDerivedClass() print(issubclass(MyDerivedClass,MyBaseClass)) # issubclass 只是用来衡量两个类对象之间的关系。 print(isinstance(base,MyBaseClass)) # isinstance 用来衡量类对象与实例对象之间的关系。 print(type(base)) print(base.__class__) # 显示object的type/类 print(type(type(base))) # type 是元类 base.print_name() \u0026#39;\u0026#39;\u0026#39; print_name是一个function object，是MyBaseClass的一个属性，base.print_name会调用`_get_`生成一个临时的boudingd method方法。然后再调用 \u0026#39;\u0026#39;\u0026#39; with 1 2 with b as a: code 等价流程\na = b.enter code b.exit as a 是一个option，不是必须的\n异常处理 try 模块中通过raise抛出异常 {except else(可选)}处理异常情况 or 不处理 finally(可选) 执行相关代码 如果异常没有处理，则继续向上传送异常。 读取可变长度参数 1 2 3 def print_two(*args): arg1, arg2 = args print(f\u0026#34;arg1: {arg1}, arg2: {arg2}\u0026#34;) numpy numpy 中matrix是array的一个子类，是严格意义上的二维矩阵，区别是*在matrix是矩阵乘法,而array是代表对应位置的元素相乘。\n叉乘(标准) 点乘(逐元素) array dot @ multiply * matrix dot @ * multiply @新版本推荐使用这个符号来表示矩阵的乘法 numpy 会自动把列向量转成行向量, 转置操作对行向量无效,需要reshape。\nnp.array([1,2,3]) //这是一个数组（行向量），shape为(3,),无法执行转置T,可以reshape np.array([[1,2,3]]) //这是一个矩阵,shape为（1*3） 产生随机数 np.random.rand(50)*100\n产生顺序值 np.arange(3,7,2)\n将二维变成1维 x.flatten()\n里面的索引方式都是先行后列的，创建shape的时候也是如此。\ndataframe dataframe 是一列列series对象(numpy的增强版)的集合. 列读取 df['time'] //取出其中的一列,取出的是series对象，这里不能用数字/index,需要string df[['time']] //取出其中的一列，取出的是一个data frame 对象， 因为[\u0026rsquo;time\u0026rsquo;],实际上是一个list. 行读取 df.iloc[0] /基于row number，输入行号,不是索引值,这里返回同样是一个series对象 df.iloc[[0]] //取出的就是一个dataframe对象 df.loc[\u0026quot;john\u0026quot;] //基于index的具体内容 注意，[]不一定完全是按照列读取，如果使用df[1:3],是按照行去读取，这里容易出错。 Ref: https://pandas.pydata.org/pandas-docs/version/1.3/user_guide/10min.html\nnumpy、series、dataframe的区别 series是带索引的增强版numpy,其索引可以是任意类型的数据，支持分区提取，例如data[\u0026lsquo;c\u0026rsquo;:\u0026lsquo;f\u0026rsquo;] 在索引的时候，中括号内的整数其实指的是索引数组中的实际值，而不是位置值，如果，我们按照位置来取值的话，反而会出错。例如a[0]\ndataframe相同索引的Series对象排列，就形成了DataFrame。 constants, variables, operations in tensorflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # first, create a TensorFlow constant const = tf.constant(2.0, name=\u0026#34;const\u0026#34;) # create TensorFlow variables b = tf.Variable(2.0, name=\u0026#39;b\u0026#39;) c = tf.Variable(1.0, name=\u0026#39;c\u0026#39;) # now create some operations d = tf.add(b, c, name=\u0026#39;d\u0026#39;) e = tf.add(c, const, name=\u0026#39;e\u0026#39;) a = tf.multiply(d, e, name=\u0026#39;a\u0026#39;) # setup the variable initialisation init_op = tf.global_variables_initializer() with tf.Session() as sess: # initialise the variables sess.run(init_op) # compute the output of the graph a_out = sess.run(a) print(\u0026#34;Variable a is {}\u0026#34;.format(a_out)) print(\u0026#34;Variable a is {}\u0026#34;.format(const)) as the Python code runs through these commands, the variables haven’t actually been declared as they would have been if you just had a standard Python declaration (i.e. b = 2.0). Instead, all the constants, variables, operations and the computational graph are only created when the initialisation commands are run. d e f is not a variable but an operation 参数传递 所有的都是引用传递，但是不可变对象重新赋值的时候，会产生一个新对象。\n可变对象（比如字典或者列表） 不可变对象（比如数字、字符或者元组） 对象的几种移除方法差别 remove 移除对应value的元素 pop 移除对应index的元素，并且返回改对象 del 移除对应index的元素 Ref: https://stackoverflow.com/questions/11520492/difference-between-del-remove-and-pop-on-lists\nassert用法 1 2 #if condition returns False, AssertionError is raised: assert x == \u0026#34;goodbye\u0026#34;, \u0026#34;x should be \u0026#39;hello\u0026#39;\u0026#34; 判断相等 == 判断两个对象是否相等 is 判断两个对象是否为同一个对象 Iterator 常用以下函数\niter() 可以返回第一个元素的迭代器 next() 跳到下一个元素，但是返回当前元素 filter() 函数返回指向所有合格的元素的迭代器 Generator Generator 是Iterator的子类,print(issubclass(Generator,Iterator))。通过yield关键字创建，主要有一下两种方式\n1 2 3 4 5 6 7 8 9 10 # way 1 num_generator = (x*2 for x in range(1,3)) # 不能使用中括号`num_list = [x*2 for x in range(1,3)]`，否则就变成了list # way2 def firstn(n): num = 0 while num \u0026lt; n: yield num # 下一次进入从这里执行。 num += 1 Decorator 装饰器就是给函数增加前置或者后置的操作，内部是执行装饰器函数，然后把被装饰的对象传入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import time def decorator(func): def wrapper(*args, **kwargs): start_time = time.time() func() end_time = time.time() print(end_time - start_time) return wrapper @decorator def func(): time.sleep(0.8) func() # 函数调用# 输出：0.800644397735595 # 执行func()，其实是在执行 decorator(func) 类装饰器与普通装饰器也类似，__call__实际上类似重载了()运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Decorator(object): def __init__(self, f): self.f = f def __call__(self): print(\u0026#34;decorator start\u0026#34;) self.f() print(\u0026#34;decorator end\u0026#34;) @decorator def func(): pass p = Decorator(func) # p是类Decorator的一个实例 p() # 实现了__call__()方法后，p可以被调用 Descriptor Definition：一种特殊的class,如果一个Class有__get__,__set__,__delete__方法，那么这个Class就是一个Descriptor.\n当外界access(get,set,delete)这个变量时，就会自动调用相应的函数 Descriptors only work when used as class variables. When put in instances, they have no effect. 所有的function都包含__get__, 都是descriptor, 准确点是non-data descriptor. 等同代码 f.x would cause type(f).__dict__['x'].__get__ to be called, and f.x = 3 would call type(f).__dict__['x'].__set__(3). 1 2 3 4 5 6 7 8 9 10 11 12 13 class Dog: def __get__(self, obj, objtype): return \u0026#34;call the get method\u0026#34; class Cat: pass class House: d = Dog() c = Cat() print(type(House.d)) # House.d返回是一个str 对象 print(type(House.c)) # House.c返回是一个cat对象 print(type(House().d)) 1 2 3 4 5 6 7 8 9 10 11 ## 使用举例，用作数据转换 class Number: def __init__(self):self.value=0 def getx(self): return -self.value; neg_value=property(getx,None,\u0026#34;what\u0026#34;) n = Number(); n.value =10 print(n.neg_value) Ref: https://codesachin.wordpress.com/2016/06/09/the-magic-behind-attribute-access-in-python/\n__dict__ __dict__ 可以打印出对象所有的成员，及其对应的值。\n1 2 print(House.__dict__) # 两者等价 print(vars(House)) 访问属性的查找顺序(有待纠正)\ndescriptor instance.dict class.dict class attribute 是不出现在 instance attribute 里面的。\n实例方法与类方法同名 实例方法会被覆盖\n1 2 3 4 5 6 7 8 9 10 class Bar(object): def fun(self): print(\u0026#34;instance method\u0026#34;) @classmethod def fun(cls): print(\u0026#34;class method\u0026#34;) a = Bar() a.fun() Bar.fun() 两者都会print class method\n访问attribute/method原理 Object访问attribute以及调用instance method都是线调用__getattr__函数,return一个对象。这个对象如果callable, 就成了函数\n例外情况：如果这个attribute已经初始化，就不会调用getattr函数。 __getattribute__ 不管变量是否已经存在，都会调用。\n__get__ 与 __getattr__ 与 __getattribute__ 区别 查找lookuptable 找到，执行(默认/override)__get__函数 找不到，执行(默认/override)__getattr__函数 __getattribute__ 将会屏蔽上述所有操作。\n设置attribute 对某个属性进行赋值时，调用__setattr__函数\ndel 某个属性，其实也是调用函数\n1 2 3 @name.deleter def name(self): self._name = \u0026#39;Number Six\u0026#39; __call__ python 的__call__属性就是重载call函数\n1 2 3 4 5 class Test: def __call__(self,a,b): print(a+b) t = Test() t(1,2) object() is shorthand for object.call()\n","date":"2017-08-25T00:00:00Z","permalink":"https://www.coderyes.com/p/python/","title":"Python"}]